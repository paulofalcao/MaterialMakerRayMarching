{"connections":[{"from":"pxflib","from_port":0,"to":"scale_2","to_port":0},{"from":"pxflib_2","from_port":0,"to":"pxflib_3","to_port":0},{"from":"pxflib_3","from_port":0,"to":"translate","to_port":0},{"from":"translate","from_port":0,"to":"pxflib","to_port":1},{"from":"sphere","from_port":0,"to":"pxflib","to_port":0}],"nodes":[{"name":"pxflib_3","node_position":{"x":-212.333328,"y":28.75},"parameters":{},"shader_model":{"code":"","global":"","inputs":[{"default":"0.0","label":"","name":"in","shortdesc":"RGBA Input","type":"rgba"}],"instance":"","longdesc":"Type - RGBA Operator\nCode - PauloFalcao\n\nTransforms a RGBA making  the Juliaset fold Z^2 transformation","name":"Juliaset Fold Z2","outputs":[{"rgba":"$in(vec2($uv.x*$uv.x-$uv.y*$uv.y,2.0*$uv.x*$uv.y))","shortdesc":"SDF3D output","type":"rgba"}],"parameters":[],"shortdesc":"Smooth Axis Symmetry"},"type":"shader"},{"name":"translate","node_position":{"x":-224.333328,"y":89.75},"parameters":{"translate_x":0.23,"translate_y":0.715},"type":"translate"},{"name":"pxflib_2","node_position":{"x":-214.333328,"y":-29.25},"parameters":{},"shader_model":{"code":"","global":"","inputs":[],"instance":"","longdesc":"Type - V4->V4 Generator\nCode - PauloFalcao\n\nInput Coordinates","name":"Axis","outputs":[{"rgba":"vec4($uv,0.0,1.0)","shortdesc":"RGBA Output","type":"rgba"}],"parameters":[],"shortdesc":"Axis"},"type":"shader"},{"name":"sphere","node_position":{"x":-245.333328,"y":-209.25},"parameters":{"cx":0.5,"cy":0.5,"r":1.05},"type":"sphere"},{"name":"pxflib","node_position":{"x":93.666672,"y":-146.25},"parameters":{"blend_type":8,"iterations":24,"mode":0,"opacity":0.641},"shader_model":{"code":"","global":"vec3 blendf_normal(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blendf_multiply(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blendf_screen( vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blendf_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blendf_overlay(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blendf_overlay_f(c1.x, c2.x), blendf_overlay_f(c1.y, c2.y), blendf_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blendf_hard_light(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blendf_overlay(c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blendf_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blendf_soft_light( vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blendf_soft_light_f(c1.x, c2.x), blendf_soft_light_f(c1.y, c2.y), blendf_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blendf_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blendf_burn(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blendf_burn_f(c1.x, c2.x), blendf_burn_f(c1.y, c2.y), blendf_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blendf_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blendf_dodge(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blendf_dodge_f(c1.x, c2.x), blendf_dodge_f(c1.y, c2.y), blendf_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blendf_lighten(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blendf_darken(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blendf_difference(vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\n","inputs":[{"default":"0.0","function":true,"label":"Image","longdesc":"The image that will be repeated","name":"img","shortdesc":"RGBA Image","type":"rgba"},{"default":"vec4($uv,0.0,0.0)","function":true,"label":"2D Transformation","longdesc":"The transformation that will be applied each iteration, only transformations nodes can be used, like translate, scale, etc","name":"trans2d","shortdesc":"Image Transformaton","type":"rgba"}],"instance":"vec4 for_blend_$name(vec2 p) {\n  vec2 t=p;\n  vec4 o=$img(t);\n  for(int i=0;i<$iterations;i++){\n    t=$trans2d(t).xy;\n\tvec4 no=$img(t);\n\to=vec4(blendf_$blend_type(o.xyz,no.xyz,$opacity),mix(o.w,no.w,$opacity));\n  }\n  return o;\n}\n\nvec4 for_avg_$name(vec2 p) {\n  vec2 t=p;\n  vec4 no=$img(t);\n  vec4 o=vec4(no.xyz*$opacity,no.w);\n  for(int i=0;i<$iterations;i++){\n    t=$trans2d(t).xy;\n\tno=$img(t);\n\to+=vec4(no.xyz*$opacity,no.w);\n  }\n  return vec4(o/($iterations.0+1.0));\n}\n\nvec4 for_fold_$name(vec2 p) {\n  vec2 t=p;\n  for(int i=0;i<$iterations;i++){\n    t=$trans2d(t).xy;\n  }\n  vec4 no=$img(t);\n  vec4 o=vec4(no.xyz*$opacity,no.w);\n  return o;\n}\n","longdesc":"Type - RGBA Generator\nCode - PauloFalcao, RodZilla  (Bending modes)\n\nRepeats a shape x Iterations times, and for each iteration uses the transformation in 2D Transformation Node.\n\n2D Transformation nodes should start with the Image \"Axis\" node, operations should not use buffer, only coordinates transformations should be used, nodes that transform colors here will transform space.\n\nThere are 3 modes available:\n - Average\n     Transforms space each iteration.\n     The input image is evaluated for each iteration, and at the end the average of all evaluations is returned.\n     Using operators like Mirror is possible to repeat space.\n - Blend\n     Transforms space each iteration.\n     The input image is evaluated for each iteration.\n     Each iteration the previous image is combined with the current only using the specified blending mode.\n     Using operators like Mirror is possible to repeat space.\n - Fold\n     Transforms space each iteration.\n     The input image is evaluated only at the end.\n     Using operators like Mirror is possible to repeat space.","name":"Fractal","outputs":[{"rgba":"$mode","shortdesc":"SDF3D Output","type":"rgba"}],"parameters":[{"default":24,"label":"Iterations","longdesc":"Number of Iterations","name":"iterations","type":"enum","values":[{"name":"0","value":"0"},{"name":"1","value":"1"},{"name":"2","value":"2"},{"name":"3","value":"3"},{"name":"4","value":"4"},{"name":"5","value":"5"},{"name":"6","value":"6"},{"name":"7","value":"7"},{"name":"8","value":"8"},{"name":"9","value":"9"},{"name":"10","value":"10"},{"name":"11","value":"11"},{"name":"12","value":"12"},{"name":"13","value":"13"},{"name":"14","value":"14"},{"name":"15","value":"15"},{"name":"16","value":"16"},{"name":"17","value":"17"},{"name":"18","value":"18"},{"name":"19","value":"19"},{"name":"20","value":"20"},{"name":"21","value":"21"},{"name":"22","value":"22"},{"name":"23","value":"23"},{"name":"24","value":"24"}]},{"default":2,"label":"Mode","longdesc":" - Average\n     Transforms space each iteration.\n     The input image is evaluated for each iteration, and at the end the average of all evaluations is returned.\n     Using operators like Mirror is possible to repeat space.\n - Blend\n     Transforms space each iteration.\n     The input image is evaluated for each iteration.\n     Each iteration the previous image is combined with the current only using the specified blending mode.\n     Using operators like Mirror is possible to repeat space.\n - Fold\n     Transforms space each iteration.\n     The input image is evaluated only at the end.\n     Using operators like Mirror is possible to repeat space.","name":"mode","type":"enum","values":[{"name":"Average","value":"for_avg_$name($uv)"},{"name":"Blend","value":"for_blend_$name($uv)"},{"name":"Fold","value":"for_fold_$name($uv)"}]},{"default":0,"label":"Blend Mode","longdesc":"The algorithm used to blend the result of each iteration","name":"blend_type","shortdesc":"Blend mode","type":"enum","values":[{"name":"Normal","value":"normal"},{"name":"Multiply","value":"multiply"},{"name":"Screen","value":"screen"},{"name":"Overlay","value":"overlay"},{"name":"Hard Light","value":"hard_light"},{"name":"Soft Light","value":"soft_light"},{"name":"Burn","value":"burn"},{"name":"Dodge","value":"dodge"},{"name":"Lighten","value":"lighten"},{"name":"Darken","value":"darken"},{"name":"Difference","value":"difference"}]},{"control":"None","default":0.5,"label":"Opacity","longdesc":"The opacity of the blend operation","max":1,"min":0,"name":"opacity","step":0.001,"type":"float"}],"shortdesc":"Fractal"},"type":"shader"},{"name":"scale_2","node_position":{"x":162.666672,"y":19.75},"parameters":{"cx":0,"cy":0,"scale_x":0.5,"scale_y":0.5},"type":"scale"}]}