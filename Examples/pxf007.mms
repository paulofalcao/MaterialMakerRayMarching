{"connections":[{"from":"pxflib","from_port":0,"to":"sdf3d_smoothboolean","to_port":0},{"from":"sdf3d_sphere","from_port":0,"to":"sdf3d_smoothboolean","to_port":1},{"from":"sdf3d_smoothboolean","from_port":0,"to":"sdf3d_rotate_2","to_port":0},{"from":"sdf3d_rotate_2","from_port":0,"to":"pxflib_2","to_port":0},{"from":"sdf3d_sphere_2","from_port":0,"to":"pxflib_3","to_port":0},{"from":"pxflib_3","from_port":0,"to":"tex3d_colorize_3","to_port":0},{"from":"tex3d_colorize_3","from_port":0,"to":"pxflib_2","to_port":1}],"nodes":[{"name":"sdf3d_sphere","node_position":{"x":-330.25,"y":10.6875},"parameters":{"r":1.36},"type":"sdf3d_sphere"},{"name":"sdf3d_sphere_2","node_position":{"x":-336.25,"y":88.6875},"parameters":{"r":0.54},"type":"sdf3d_sphere"},{"name":"pxflib","node_position":{"x":-377.25,"y":-254.3125},"parameters":{"Correction":2,"Distance":0,"scale":2.06879,"scale_x":1,"scale_y":1,"scale_z":1,"translate_x":0,"translate_y":0,"translate_z":0},"shader_model":{"code":"","global":"// https://www.shadertoy.com/view/XsX3zB\n//\n// The MIT License\n// Copyright Â© 2013 Nikita Miropolskiy\n// \n// ( license has been changed from CCA-NC-SA 3.0 to MIT\n//\n//   but thanks for attributing your source code when deriving from this sample \n//   with a following link: https://www.shadertoy.com/view/XsX3zB )\n//\n//\n// if you're looking for procedural noise implementation examples you might \n// also want to look at the following shaders:\n// \n// Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n//\n// Noise shaders by iq:\n//     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n//     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n//     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n//     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n//     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n//     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n//     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n//     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n//     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n//     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n//\n//\n//\n\n// discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 XsX3zB_random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n// skew constants for 3d simplex functions\nconst float XsX3zB_F3 =  0.3333333;\nconst float XsX3zB_G3 =  0.1666667;\n\n// 3d simplex noise\nfloat XsX3zB_simplex3d(vec3 p) {\n\t // 1. find current tetrahedron T and it's four vertices\n\t // s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices\n\t // x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices\n\t \n\t // calculate s and x\n\t vec3 s = floor(p + dot(p, vec3(XsX3zB_F3)));\n\t vec3 x = p - s + dot(s, vec3(XsX3zB_G3));\n\t \n\t // calculate i1 and i2\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t // x1, x2, x3\n\t vec3 x1 = x - i1 + XsX3zB_G3;\n\t vec3 x2 = x - i2 + 2.0*XsX3zB_G3;\n\t vec3 x3 = x - 1.0 + 3.0*XsX3zB_G3;\n\t \n\t // 2. find four surflets and store them in d\n\t vec4 w, d;\n\t \n\t // calculate surflet weights\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t // w fades from 0.6 at the center of the surflet to 0.0 at the margin\n\t w = max(0.6 - w, 0.0);\n\t \n\t // calculate surflet components\n\t d.x = dot(XsX3zB_random3(s), x);\n\t d.y = dot(XsX3zB_random3(s + i1), x1);\n\t d.z = dot(XsX3zB_random3(s + i2), x2);\n\t d.w = dot(XsX3zB_random3(s + 1.0), x3);\n\t \n\t // multiply d by w^4\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t // 3. return the sum of the four surflets\n\t return dot(d, vec4(52.0));\n}","inputs":[],"instance":"","longdesc":"Type - SDF3D Generator\nCode - Nikat\n\nMakes a non periodic noise using nikat code from https://www.shadertoy.com/view/XsX3zB","name":"Simplex Noise","outputs":[{"sdf3d":"(XsX3zB_simplex3d(($uv.xyz+vec3($translate_x,$translate_y,$translate_z))*vec3($scale_x,$scale_y,$scale_z)*$scale))/(1.0+$Correction*$scale)-$Distance","shortdesc":"TEX3D Output","type":"sdf3d"}],"parameters":[{"control":"None","default":8,"label":"Scale","longdesc":"Noise scale","max":32,"min":0,"name":"scale","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Scale X","longdesc":"Noise X scale","max":16,"min":0,"name":"scale_x","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Scale Y","longdesc":"Noise Y scale","max":16,"min":0,"name":"scale_y","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Scale Z","longdesc":"Noise Z scale","max":16,"min":0,"name":"scale_z","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Translate X","longdesc":"Noise X Translation","max":100,"min":0,"name":"translate_x","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Translate Y","longdesc":"Noise Y Translation","max":100,"min":0,"name":"translate_y","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Translate Z","longdesc":"Noise Z Translation","max":100,"min":0,"name":"translate_z","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Distance","longdesc":"Distance to surface","max":0.5,"min":-0.5,"name":"Distance","step":0.001,"type":"float"},{"control":"None","default":2,"label":"Correction","longdesc":"Keep this value as low as possible!\nIncrease this correction value if the resulting SDF is not perfect.\nA higher value will increase ray marching loop iterations and will result in higher render times.","max":10,"min":0,"name":"Correction","step":0.001,"type":"float"}],"shortdesc":"Simplex Noise"},"type":"shader"},{"name":"pxflib_3","node_position":{"x":-129.25,"y":82.6875},"parameters":{},"shader_model":{"code":"float o_$name_uv=$in($uv.xyz);","global":"","inputs":[{"default":"0.0","label":"","name":"in","shortdesc":"SDF3D Input","type":"sdf3d"}],"instance":"","longdesc":"Type - SDF3D to TEX3D\nCode - PauloFalcao\n\nConverts a SDF3D to a grayscale TEX3D","name":"SDF3D to TEX3D","outputs":[{"shortdesc":"TEX3D Output","tex3d":"vec3(o_$name_uv,o_$name_uv,o_$name_uv)","type":"tex3d"}],"parameters":[]},"type":"shader"},{"name":"tex3d_colorize_3","node_position":{"x":85.75,"y":75.6875},"parameters":{"g":{"interpolation":1,"points":[{"a":1,"b":0.097656,"g":0.083542,"pos":0.509091,"r":0.083542},{"a":1,"b":0,"g":0.46875,"pos":0.745455,"r":1}],"type":"Gradient"}},"type":"tex3d_colorize"},{"name":"sdf3d_smoothboolean","node_position":{"x":-99.25,"y":-158.3125},"parameters":{"k":0.2,"op":2},"type":"sdf3d_smoothboolean"},{"name":"sdf3d_rotate_2","node_position":{"x":95.75,"y":-161.3125},"parameters":{"ax":"$time*31.0","ay":"$time*27.0","az":"$time*11.0"},"type":"sdf3d_rotate"},{"name":"pxflib_2","node_position":{"x":307.75,"y":-198.3125},"parameters":{"AmbLight":0.25,"AmbOcclusion":0.26,"CamD":1.5,"CamX":2.5,"CamY":2,"CamZ":3,"CamZoom":1,"LookAtX":0,"LookAtY":0,"LookAtZ":0,"Pow":64,"Reflection":0.2,"Shadow":1,"Specular":0,"SunX":2.5,"SunY":2.5,"SunZ":1},"shader_model":{"code":"","global":"const float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\n","inputs":[{"default":"length($uv)-0.4","function":true,"label":"SDF3D A","name":"sdf_a","shortdesc":"SDF3D A","type":"sdf3d"},{"default":"vec3(1.0,0.1,0.1)","function":true,"label":"TEX3D A","name":"tex3d_a","shortdesc":"TEX3D A","type":"tex3d"},{"default":"max($uv.y+1.0,length(vec3($uv.x,$uv.y+1.0,$uv.z))-10.0)","function":true,"label":"SDF3D B","name":"sdf_b","shortdesc":"SDF3D B","type":"sdf3d"},{"default":"vec3(mod(floor($uv.x*2.0)+floor($uv.z*2.0),2.0))*0.9+0.1","function":true,"label":"TEX3D B","name":"tex3d_b","shortdesc":"TEX3D B","type":"tex3d"},{"default":"Simple360HDR_make360hdri(vec2($uv.x,-$uv.y+1.0),normalize(vec3(-$SunX,$SunY,-$SunZ)))","function":true,"label":"360 HDRI Image","longdesc":"By default uses a very simple procedural hdri 360 image\nUse other procedural HDRI images from /PauloFalcao/Image/Generator\nOr download real ones from https://hdrihaven.com/","name":"hdri","shortdesc":"Image 360 HDRI","type":"rgb"}],"instance":"vec2 input_$name(vec3 p) {\n    float sdfa=$sdf_a(p);\n\tfloat sdfb=$sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_$name(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_$name(p+e.xyy).x;\n  float v2=input_$name(p+e.yyx).x;\n  float v3=input_$name(p+e.yxy).x;\n  float v4=input_$name(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_$name(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_$name(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_$name( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_$name( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_$name( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_$name( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_$name(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3($CamX,$CamY,$CamZ)*$CamZoom;\n\tvec3 lookat=vec3($LookAtX,$LookAtY,$LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*$CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_$name(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?$tex3d_a(vec4(p,1.0)):$tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3($SunX,$SunY,$SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_$name(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_$name(p,n),$AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_$name(p,light,0.05,5.0),$Shadow);\n\t\tcolor=min(vec3(max(shadow,$AmbLight)),max(l,$AmbLight))*max(cAO,$AmbLight)*objColor+pow(r,$Pow)*$Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_$name(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?$tex3d_a(vec4(p,1.0)):$tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_$name(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,$AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=$hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,$Reflection);\n\t} else {\n\t\tcolor=$hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}","longdesc":"Type - SDF3D Render\nCode - PauloFalcao, IQ\n\nRay marching node for 2 objects using a environment 360 HDRI image\nBy default uses a very simple procedural hdri 360 image\nUse other procedural HDRI images from /PauloFalcao/Image/Generator\nOr download real ones from https://hdrihaven.com/\n\n","name":"Ray Marching 360 HDRI Image","outputs":[{"rgb":"raymarch_$name($uv)","shortdesc":"Image output","type":"rgb"}],"parameters":[{"control":"None","default":0,"label":"CamX","longdesc":"Camera position X","max":5,"min":-5,"name":"CamX","step":0.001,"type":"float"},{"control":"None","default":1,"label":"CamY","longdesc":"Camera position Y","max":5,"min":-5,"name":"CamY","step":0.001,"type":"float"},{"control":"None","default":2,"label":"CamZ","longdesc":"Camera position Z","max":5,"min":-5,"name":"CamZ","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtX","longdesc":"Look at position with coordinate X","max":5,"min":-5,"name":"LookAtX","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtY","longdesc":"Look at position with coordinate Y","max":5,"min":-5,"name":"LookAtY","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtZ","longdesc":"Look at position with coordinate Z","max":5,"min":-5,"name":"LookAtZ","step":0.001,"type":"float"},{"control":"None","default":5,"label":"CamDistance","longdesc":"Camera distance to the view plane, used to define the Field Of View","max":5,"min":0,"name":"CamD","step":0.001,"type":"float"},{"control":"None","default":1,"label":"CamZoom","longdesc":"Camera zoom","max":5,"min":0,"name":"CamZoom","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Reflection","longdesc":"Reflection strength, reflects other objects or the environment HDRI 360 image ","max":1,"min":0,"name":"Reflection","step":0.001,"type":"float"},{"control":"None","default":0.4,"label":"Specular","longdesc":"Objects shading specular component strength, it's the strength  of the highlight.","max":1,"min":0,"name":"Specular","step":0.001,"type":"float"},{"control":"None","default":32,"label":"Pow","longdesc":"Shininess of the specular component, it's the size of the specular component, it tries to simulate more shininess surfaces or more rough surfaces.","max":1024,"min":0,"name":"Pow","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunX","longdesc":"Sun position coordinate X","max":10,"min":-10,"name":"SunX","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunY","longdesc":"Sun position coordinate Y","max":10,"min":-10,"name":"SunY","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunZ","longdesc":"Sun position coordinate Z","max":10,"min":-10,"name":"SunZ","step":0.001,"type":"float"},{"control":"None","default":0.2,"label":"AmbLight","longdesc":"Strength of ambient light","max":1,"min":0,"name":"AmbLight","step":0.001,"type":"float"},{"control":"None","default":1,"label":"AmbOcclusion","longdesc":"Strength of ambient occlusion","max":1,"min":0,"name":"AmbOcclusion","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Shadow","longdesc":"Shadow strength","max":1,"min":0,"name":"Shadow","step":0.001,"type":"float"}]},"type":"shader"}]}