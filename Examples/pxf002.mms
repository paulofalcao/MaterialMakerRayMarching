{"connections":[{"from":"pxflib_2","from_port":0,"to":"pxflib_3","to_port":0},{"from":"pxflib_4","from_port":0,"to":"pxflib_5","to_port":0},{"from":"sdf3d_rotate_2","from_port":0,"to":"pxflib","to_port":0},{"from":"sdf3d_sphere","from_port":0,"to":"pxflib_6","to_port":0},{"from":"pxflib_5","from_port":0,"to":"pxflib_6","to_port":1},{"from":"pxflib_6","from_port":0,"to":"sdf3d_rotate_2","to_port":0},{"from":"pxflib_3","from_port":0,"to":"pxflib_7","to_port":0},{"from":"pxflib_7","from_port":0,"to":"pxflib_4","to_port":0}],"nodes":[{"name":"pxflib_2","node_position":{"x":-314.111115,"y":-150.635803},"parameters":{},"shader_model":{"code":"","global":"","inputs":[],"instance":"","longdesc":"Type - V4->V4 Generator\nCode - PauloFalcao\n\nInput Coordinates","name":"Axis","outputs":[{"shortdesc":"V4->V4 Coordinates Output","type":"v4v4","v4v4":"$uv"}],"parameters":[],"shortdesc":"Axis"},"type":"shader"},{"name":"pxflib_3","node_position":{"x":-320.111115,"y":-106.635803},"parameters":{"ax":"sin($time*0.05)*360.0","ay":"sin($time*0.07)*360.0","az":"sin($time*0.03)*360.0"},"shader_model":{"code":"","global":"vec3 v4v4_rotate(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n","inputs":[{"default":"vec3(1.0)","label":"","name":"in","shortdesc":"V4->V4 Input","type":"v4v4"}],"instance":"","longdesc":"Type - SDF3D Operator\nCode - RodZilla, PauloFalcao\n\nRotates a V4->V4\nAdapted from RodZilla TEX3D Rotate","name":"Rotate","outputs":[{"shortdesc":"V4->V4 Ouput","type":"v4v4","v4v4":"$in(vec4(v4v4_rotate($uv.xyz, -vec3($ax, $ay, $az)*0.01745329251), $uv.w))"}],"parameters":[{"control":"None","default":0,"label":"X","longdesc":"The rotation around the X axis","max":180,"min":-180,"name":"ax","shortdesc":"Rotate.x","step":1,"type":"float"},{"control":"None","default":0,"label":"Y","longdesc":"The rotation around the Y axis","max":180,"min":-180,"name":"ay","shortdesc":"Rotate.y","step":1,"type":"float"},{"control":"None","default":0,"label":"Z","longdesc":"The rotation around the Z axis","max":180,"min":-180,"name":"az","shortdesc":"Rotate.z","step":1,"type":"float"}],"shortdesc":"V4->V4 Rotate"},"type":"shader"},{"name":"pxflib_4","node_position":{"x":-313.111115,"y":136.364197},"parameters":{"x":1,"y":1,"z":1},"shader_model":{"code":"","global":"","inputs":[{"default":"vec4(0.0)","label":"","name":"in","shortdesc":"V4->V4 Input","type":"v4v4"}],"instance":"","longdesc":"Type - V4->V4 Operator\nCode - PauloFalcao\n\nTranslates the input V4->V4 Coordinates","name":"Translate","outputs":[{"shortdesc":"V4->V4 Output","type":"v4v4","v4v4":"$in(vec4($uv.xyz-vec3($x, $y, $z),$uv.w))"}],"parameters":[{"control":"P1.x","default":0,"label":"X","max":1,"min":-1,"name":"x","step":0.001,"type":"float"},{"control":"P1.y","default":0,"label":"Y","max":1,"min":-1,"name":"y","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Z","max":1,"min":-1,"name":"z","step":0.001,"type":"float"}],"shortdesc":"Translate"},"type":"shader"},{"name":"pxflib_5","node_position":{"x":-314.111115,"y":240.364197},"parameters":{"mode":0,"smooth":0},"shader_model":{"code":"","global":"","inputs":[{"default":"0.0","label":"V4->V4","name":"in","shortdesc":"V4->V4 Input","type":"v4v4"}],"instance":"","longdesc":"Type - V4->V4 Operator\nCode - PauloFalcao\n\nTransforms a V4->V4 making a mirror smooth symmetry using the chosen axis","name":"Smooth Axis Symmetry","outputs":[{"shortdesc":"V4->V4 output","type":"v4v4","v4v4":"$in(vec4(vec3($mode),$uv.w))"}],"parameters":[{"default":0,"label":"Axis","longdesc":"Axis","name":"mode","type":"enum","values":[{"name":"XYZ","value":"sqrt($uv.xyz*$uv.xyz+$smooth)"},{"name":"XY","value":"sqrt($uv.xy*$uv.xy+$smooth),$uv.z"},{"name":"XZ","value":"sqrt($uv.x*$uv.x+$smooth),$uv.y,sqrt($uv.z*$uv.z+$smooth)"},{"name":"YZ","value":"$uv.x,sqrt($uv.yz*$uv.yz+$smooth)"},{"name":"X","value":"sqrt($uv.x*$uv.x+$smooth),$uv.yz"},{"name":"Y","value":"$uv.x,sqrt($uv.y*$uv.y+$smooth),$uv.z"},{"name":"Z","value":"$uv.x,$uv.y,sqrt($uv.z*$uv.z+$smooth)"}]},{"control":"None","default":0,"label":"Smooth","longdesc":"Smooth amount","max":1,"min":0,"name":"smooth","step":0.001,"type":"float"}],"shortdesc":"Smooth Axis Symmetry"},"type":"shader"},{"name":"pxflib_7","node_position":{"x":-323.111115,"y":-8.024689},"parameters":{"mode":1,"x":1,"xyz":0.452,"y":1,"z":1},"shader_model":{"code":"vec4 o_$name_uv=$in(vec4($uv.xyz/vec3($x, $y, $z)/$xyz,$uv.w));","global":"","inputs":[{"default":"vec4(0.0)","label":"","name":"in","shortdesc":"V4->V4 Input","type":"v4v4"}],"instance":"","longdesc":"Type - V4->V4 Operator\nCode - PauloFalcao\n\nScales the input V4->V4 Coordinates","name":"Scale","outputs":[{"shortdesc":"V4->V4 Output","type":"v4v4","v4v4":"$mode"}],"parameters":[{"control":"P1.x","default":1,"label":"XYZ","longdesc":"Scales all axis","max":1,"min":-1,"name":"xyz","step":0.001,"type":"float"},{"control":"None","default":1,"label":"X","longdesc":"Scale X axis","max":1,"min":-1,"name":"x","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Y","longdesc":"Scale Y axis","max":1,"min":-1,"name":"y","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Z","longdesc":"Scale Z axis","max":1,"min":-1,"name":"z","step":0.001,"type":"float"},{"default":1,"label":"Mode","longdesc":"- Multi-Field SDF mode is the default mode used for scaling Multi-Field SDF objects.\n- Coordinates Transformation is the mode that should be used for coordinates transformations operations, like in the fractal node input V4->V4 3D Transformation","name":"mode","type":"enum","values":[{"name":"Multi-Field SDF (def. mode)","value":"vec4(o_$name_uv.xyz,o_$name_uv.w*min(min($x, $y), $z)*$xyz)"},{"name":"Coordinates Transformation","value":"vec4(o_$name_uv.xyz,$uv.w/min(min($x, $y), $z)/$xyz)"}]}],"shortdesc":"Translate"},"type":"shader"},{"name":"sdf3d_rotate_2","node_position":{"x":469.888885,"y":-195.635803},"parameters":{"ax":"$time*21.0","ay":"$time*27.0","az":"$time*23.0"},"type":"sdf3d_rotate"},{"name":"pxflib_6","node_position":{"x":81.888885,"y":-199.024689},"parameters":{"iterations":6,"mode":1},"shader_model":{"code":"","global":"","inputs":[{"default":"0.0","function":true,"label":"SDF3D","longdesc":"The object that will be repeated","name":"obj3d","shortdesc":"SDF3D","type":"sdf3d"},{"default":"vec4(0.0)","function":true,"label":"V4->V4 3D Transformation","longdesc":"The transformation that will be applied each iteration","name":"trans3d","shortdesc":"V4->V4 Transformation","type":"v4v4"},{"default":"min($uv.x,$uv.y)","function":true,"label":"SDF2D Custom Boolean","longdesc":"(opcional) The combine operation, defined as a SDF2D.\nWill be applied after each SDF3D evaluation to combine with the previous result.","name":"custombool","shortdesc":"SDF2D Join","type":"sdf2d"}],"instance":"float for_fold_$name(vec4 p) {\n  for(int i=0;i<$iterations;i++){\n    p=$trans3d(p);\n  }\n  return $obj3d(p.xyz)/p.w;\n}\n\nfloat for_min_$name(vec4 p) {\n  float d=$obj3d(p.xyz);\n  float m=min(999999.0,d);\n  for(int i=0;i<$iterations;i++){\n    p=$trans3d(p);\n\td=$obj3d(p.xyz);\n\tm=min(m,d/p.w);\n  }\n  return m;\n}\n\nfloat for_custom_$name(vec4 p) {\n  float d=$obj3d(p.xyz);\n  float m=$custombool(vec2(999999.0,d));\n  for(int i=0;i<$iterations;i++){\n    p=$trans3d(p);\n\td=$obj3d(p.xyz);\n\tm=$custombool(vec2(m,d/p.w));\n  }\n  return m;\n}","longdesc":"Type - SDF3D Generator\nCode - PauloFalcao\n\nRepeats a shape x Iterations times, and for each iteration uses the transformation in 3D Transformation Node.\n\n3D transformation node uses the generic V4->V4 Type\n\nThere are 3 modes available:\n - Fold\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated only once after the last iteration.\n     Using operators like Axis Symmetry is possible to repeat space.\n - Min\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated for each iteration,\n     and combined with the previous result using the min operation.\n - Custom\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated for each iteration,\n     and combined with the previous result using the custom SDF2D operation.","name":"Fractal","outputs":[{"sdf3d":"$mode","shortdesc":"SDF3D Output","type":"sdf3d"}],"parameters":[{"default":24,"label":"Iterations","longdesc":"Number of Iterations","name":"iterations","type":"enum","values":[{"name":"0","value":"0"},{"name":"1","value":"1"},{"name":"2","value":"2"},{"name":"3","value":"3"},{"name":"4","value":"4"},{"name":"5","value":"5"},{"name":"6","value":"6"},{"name":"7","value":"7"},{"name":"8","value":"8"},{"name":"9","value":"9"},{"name":"10","value":"10"},{"name":"11","value":"11"},{"name":"12","value":"12"},{"name":"13","value":"13"},{"name":"14","value":"14"},{"name":"15","value":"15"},{"name":"16","value":"16"},{"name":"17","value":"17"},{"name":"18","value":"18"},{"name":"19","value":"19"},{"name":"20","value":"20"},{"name":"21","value":"21"},{"name":"22","value":"22"},{"name":"23","value":"23"},{"name":"24","value":"24"}]},{"default":0,"label":"Mode","longdesc":"Iteration combine mode.\n - Fold\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated only once after the last iteration.\n     Using operators like Axis Symmetry is possible to repeat space.\n - Min\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated for each iteration,\n     and combined with the previous result using the min operation.\n - Custom\n     Transforms space x Iterations times.\n     The object SDF3D is evaluated for each iteration,\n     and combined with the previous result using the custom SDF2D operation.","name":"mode","type":"enum","values":[{"name":"Fold","value":"for_fold_$name(vec4($uv,1.0))"},{"name":"Min","value":"for_min_$name(vec4($uv,1.0))"},{"name":"Custom","value":"for_custom_$name(vec4($uv,1.0))"}]}],"shortdesc":"Fractal"},"type":"shader"},{"name":"sdf3d_sphere","node_position":{"x":-314.111115,"y":-246.635803},"parameters":{"r":2.514,"x":0.024},"shader_model":{"code":"","global":"float iq_sdOctahedron( vec3 p, float s){\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}","inputs":[],"instance":"","longdesc":"Type - SDF3D Generator\nCode - IQ\n\nGenerates a Octahedron as a signed distance function\nCode from www.iquilezles.org/www/articles/distfunctions/distfunctions.htm","name":"Octahedron","outputs":[{"sdf3d":"iq_sdOctahedron($uv,$r)-$x","shortdesc":"SDF3D Output","type":"sdf3d"}],"parameters":[{"control":"Radius1.r","default":0.5,"label":"Size","longdesc":"The size of the Octahedron","max":1,"min":0,"name":"r","step":0.001,"type":"float"},{"control":"None","default":0.5,"label":"Rounding","longdesc":"Roundness of the object","max":1,"min":0,"name":"x","step":0.001,"type":"float"}],"shortdesc":"Octahedron"},"type":"shader"},{"name":"pxflib","node_position":{"x":297.888885,"y":-39.635803},"parameters":{"AmbLight":0.25,"AmbOcclusion":0.502,"CamD":1.5,"CamX":"sin(sin($time*0.2)*0.5+0.5)*4.0","CamY":2,"CamZ":"sin(sin($time*0.3)*0.5+0.5)*4.0","CamZoom":1.972,"LookAtX":0,"LookAtY":0,"LookAtZ":0,"Pow":64,"Reflection":0.2,"Shadow":1,"Specular":0,"SunX":2.5,"SunY":2.5,"SunZ":1},"shader_model":{"code":"","global":"const float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\n","inputs":[{"default":"length($uv)-0.4","function":true,"label":"SDF3D A","name":"sdf_a","shortdesc":"SDF3D A","type":"sdf3d"},{"default":"vec3(1.0,0.1,0.1)","function":true,"label":"TEX3D A","name":"tex3d_a","shortdesc":"TEX3D A","type":"tex3d"},{"default":"max($uv.y+1.0,length(vec3($uv.x,$uv.y+1.0,$uv.z))-10.0)","function":true,"label":"SDF3D B","name":"sdf_b","shortdesc":"SDF3D B","type":"sdf3d"},{"default":"vec3(mod(floor($uv.x*2.0)+floor($uv.z*2.0),2.0))*0.9+0.1","function":true,"label":"TEX3D B","name":"tex3d_b","shortdesc":"TEX3D B","type":"tex3d"},{"default":"Simple360HDR_make360hdri(vec2($uv.x,-$uv.y+1.0),normalize(vec3(-$SunX,$SunY,-$SunZ)))","function":true,"label":"360 HDRI Image","longdesc":"By default uses a very simple procedural hdri 360 image\nUse other procedural HDRI images from /PauloFalcao/Image/Generator\nOr download real ones from https://hdrihaven.com/","name":"hdri","shortdesc":"Image 360 HDRI","type":"rgb"}],"instance":"vec2 input_$name(vec3 p) {\n    float sdfa=$sdf_a(p);\n\tfloat sdfb=$sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_$name(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_$name(p+e.xyy).x;\n  float v2=input_$name(p+e.yyx).x;\n  float v3=input_$name(p+e.yxy).x;\n  float v4=input_$name(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_$name(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_$name(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_$name( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_$name( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_$name( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_$name( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_$name(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3($CamX,$CamY,$CamZ)*$CamZoom;\n\tvec3 lookat=vec3($LookAtX,$LookAtY,$LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*$CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_$name(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?$tex3d_a(vec4(p,1.0)):$tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3($SunX,$SunY,$SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_$name(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_$name(p,n),$AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_$name(p,light,0.05,5.0),$Shadow);\n\t\tcolor=min(vec3(max(shadow,$AmbLight)),max(l,$AmbLight))*max(cAO,$AmbLight)*objColor+pow(r,$Pow)*$Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_$name(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?$tex3d_a(vec4(p,1.0)):$tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_$name(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,$AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=$hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,$Reflection);\n\t} else {\n\t\tcolor=$hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}","longdesc":"Type - SDF3D Render\nCode - PauloFalcao, IQ\n\nRay marching node for 2 objects using a environment 360 HDRI image\nBy default uses a very simple procedural hdri 360 image\nUse other procedural HDRI images from /PauloFalcao/Image/Generator\nOr download real ones from https://hdrihaven.com/\n\n","name":"Ray Marching 360 HDRI Image","outputs":[{"rgb":"raymarch_$name($uv)","shortdesc":"Image output","type":"rgb"}],"parameters":[{"control":"None","default":0,"label":"CamX","longdesc":"Camera position X","max":5,"min":-5,"name":"CamX","step":0.001,"type":"float"},{"control":"None","default":1,"label":"CamY","longdesc":"Camera position Y","max":5,"min":-5,"name":"CamY","step":0.001,"type":"float"},{"control":"None","default":2,"label":"CamZ","longdesc":"Camera position Z","max":5,"min":-5,"name":"CamZ","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtX","longdesc":"Look at position with coordinate X","max":5,"min":-5,"name":"LookAtX","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtY","longdesc":"Look at position with coordinate Y","max":5,"min":-5,"name":"LookAtY","step":0.001,"type":"float"},{"control":"None","default":0,"label":"LookAtZ","longdesc":"Look at position with coordinate Z","max":5,"min":-5,"name":"LookAtZ","step":0.001,"type":"float"},{"control":"None","default":5,"label":"CamDistance","longdesc":"Camera distance to the view plane, used to define the Field Of View","max":5,"min":0,"name":"CamD","step":0.001,"type":"float"},{"control":"None","default":1,"label":"CamZoom","longdesc":"Camera zoom","max":5,"min":0,"name":"CamZoom","step":0.001,"type":"float"},{"control":"None","default":0,"label":"Reflection","longdesc":"Reflection strength, reflects other objects or the environment HDRI 360 image ","max":1,"min":0,"name":"Reflection","step":0.001,"type":"float"},{"control":"None","default":0.4,"label":"Specular","longdesc":"Objects shading specular component strength, it's the strength  of the highlight.","max":1,"min":0,"name":"Specular","step":0.001,"type":"float"},{"control":"None","default":32,"label":"Pow","longdesc":"Shininess of the specular component, it's the size of the specular component, it tries to simulate more shininess surfaces or more rough surfaces.","max":1024,"min":0,"name":"Pow","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunX","longdesc":"Sun position coordinate X","max":10,"min":-10,"name":"SunX","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunY","longdesc":"Sun position coordinate Y","max":10,"min":-10,"name":"SunY","step":0.001,"type":"float"},{"control":"None","default":1,"label":"SunZ","longdesc":"Sun position coordinate Z","max":10,"min":-10,"name":"SunZ","step":0.001,"type":"float"},{"control":"None","default":0.2,"label":"AmbLight","longdesc":"Strength of ambient light","max":1,"min":0,"name":"AmbLight","step":0.001,"type":"float"},{"control":"None","default":1,"label":"AmbOcclusion","longdesc":"Strength of ambient occlusion","max":1,"min":0,"name":"AmbOcclusion","step":0.001,"type":"float"},{"control":"None","default":1,"label":"Shadow","longdesc":"Shadow strength","max":1,"min":0,"name":"Shadow","step":0.001,"type":"float"}]},"type":"shader"}]}